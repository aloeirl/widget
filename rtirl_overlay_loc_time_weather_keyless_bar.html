<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stream Overlay</title>

  <style>
    /* Self-hosted Arial Bold */
    @font-face {
      font-family: "OverlayArialBold";
      src: url("./fonts/ARIALBD.woff2?v=7") format("woff2");
      font-weight: 700;
      font-style: normal;
      font-display: block;
    }

    /* Self-hosted Apple Emoji subset */
    @font-face {
      font-family: "OverlayAppleEmoji";
      src: url("./fonts/AppleColorEmoji-rtirl.woff2?v=7") format("woff2");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    :root {
      --bg: rgba(0,0,0,0.6);
      --fg: #ffffff;
      --border: rgba(255,255,255,0.4);
      --radius: 8px;
      --padY: 4px;
      --padX: 10px;
      --gap: 8px;
      --font: "OverlayArialBold", Arial, Helvetica, sans-serif;
    }

    html, body, #overlay, .segment, .sep, span, div, * {
      font-family: var(--font) !important;
      font-synthesis: none;
      -webkit-text-size-adjust: 100%;
      text-rendering: optimizeLegibility;
    }

    .emoji {
      font-family: "OverlayAppleEmoji","Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif !important;
      font-synthesis: none;
      line-height: 1;
      display: inline-block;
    }

    html, body { margin: 0; padding: 0; background: transparent; }
    body {
      display: inline-block;
      color: var(--fg);
      font-size: 16px;
      line-height: 1.2;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: var(--gap);
      padding: var(--padY) var(--padX);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: var(--bg);
      box-sizing: border-box;
      white-space: nowrap;
      box-shadow: 0 0 3px rgba(0,0,0,0.25), 0 1px 4px rgba(0,0,0,0.25);
      font-weight: 700;
    }

    .segment { display: inline-flex; align-items: center; gap: 6px; }
    .sep { color: var(--border); font-weight: 400; font-size: 0.85em; }
  </style>
</head>
<body>
  <div id="overlay" class="pill">
    <span id="locSeg" class="segment"><span class="emoji">üìç</span><span id="loc">Locating‚Ä¶</span></span>
    <span class="sep">|</span>
    <span id="timeSeg" class="segment"><span class="emoji">üïí</span><span id="time">--:-- --</span></span>
    <span class="sep">|</span>
    <span id="wxSeg" class="segment" style="display:none"><span id="wxEmoji" class="emoji">‚òÅÔ∏è</span><span id="weather">--</span></span>
  </div>

  <script>
    const PULL_KEY = "1wjousu7l61hzgws";
    const TEMP_UNITS = "f";
    const STALE_MS = 30 * 60 * 1000;             // 30 minutes
    const STATIONARY_GRACE_MS = 3 * 60 * 60 * 1000; // 3 hours

    const elLoc = document.getElementById("loc");
    const elTime = document.getElementById("time");
    const elWxSeg = document.getElementById("wxSeg");
    const elWeather = document.getElementById("weather");
    const elWxEmoji = document.getElementById("wxEmoji");

    let stale = false;
    let lastLat = null, lastLon = null, lastPlace = null;

    function to12h(date) {
      let h = date.getHours();
      const m = date.getMinutes();
      const ampm = h >= 12 ? "pm" : "am";
      h = h % 12; if (h === 0) h = 12;
      return `${h}:${String(m).padStart(2, "0")} ${ampm}`;
    }
    function tickClock() {
      elTime.textContent = stale ? "??????" : to12h(new Date());
    }
    setInterval(tickClock, 1000); tickClock();

    function normalizeTs(ts) {
      if (ts == null) return null;
      if (typeof ts === "string") {
        const d = Date.parse(ts);
        return Number.isNaN(d) ? null : d;
      }
      if (typeof ts === "number") {
        return ts < 1e12 ? ts * 1000 : ts;
      }
      return null;
    }
    function getLastUpdateMs(d) {
      const normalized = [
        d?.updatedAt, d?.reportedAt, d?.timestamp,
        d?.location?.updatedAt, d?.location?.reportedAt
      ].map(normalizeTs).filter(v => typeof v === "number");
      return normalized.length ? Math.max(...normalized) : null;
    }

    function approxEqual(a,b,eps=1e-4){ if(a==null||b==null) return false; return Math.abs(a-b)<=eps; }
    function extractLatLon(d){
      if (d?.location && typeof d.location.latitude==="number" && typeof d.location.longitude==="number") return {lat:d.location.latitude, lon:d.location.longitude};
      return null;
    }

    async function reverseGeocode(lat, lon) {
      const url = new URL("https://nominatim.openstreetmap.org/reverse");
      url.searchParams.set("format", "jsonv2");
      url.searchParams.set("lat", String(lat));
      url.searchParams.set("lon", String(lon));
      url.searchParams.set("accept-language", "en");
      url.searchParams.set("zoom", "15");
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("Nominatim HTTP " + res.status);
      const j = await res.json();
      const addr = j.address || {};
      const parts = [
        addr.neighbourhood || addr.neighborhood || "",
        addr.suburb || "",
        addr.city || addr.town || addr.village || ""
      ].filter(Boolean);
      return parts.length ? parts.join(", ") : (j.display_name || "").split(", ").slice(0,3).join(", ");
    }

    async function fetchRTIRL() {
      try {
        const url = `https://rtirl.com/api/pull?key=${encodeURIComponent(PULL_KEY)}&ts=${Date.now()}`;
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error("RTIRL pull failed");
        const data = await res.json();

        const lastUpdate = getLastUpdateMs(data);
        const coords = extractLatLon(data);

        let tooOld = !lastUpdate || (Date.now() - lastUpdate > STALE_MS);

        if (tooOld && coords && lastLat != null && lastLon != null) {
          const unchanged = approxEqual(coords.lat, lastLat) && approxEqual(coords.lon, lastLon);
          const AGE_MS = lastUpdate ? (Date.now() - lastUpdate) : Infinity;
          if (unchanged && AGE_MS < STATIONARY_GRACE_MS) {
            tooOld = false;
          }
        }

        if (tooOld || !coords) { showUnknown(); return; }

        stale = false;
        const { lat, lon } = coords;

        // Show only lastPlace or fallback
        if (!lastPlace || !approxEqual(lat,lastLat) || !approxEqual(lon,lastLon)) {
          reverseGeocode(lat, lon)
            .then(name => { if (name) { lastPlace = name; elLoc.textContent = name; } })
            .catch(() => { elLoc.textContent = lastPlace || "??????"; });
          lastLat = lat; lastLon = lon;
        } else {
          elLoc.textContent = lastPlace;
        }

        updateWeather(lat, lon);

      } catch (e) {
        console.error(e);
        showUnknown();
      }
    }

    function showUnknown() {
      stale = true;
      elLoc.textContent = "??????";
      elTime.textContent = "??????";
      elWxEmoji.textContent = "üåÄ";
      elWeather.textContent = "??????";
      elWxSeg.style.display = "inline-flex";
    }

    async function updateWeather(lat, lon) {
      try {
        const params = new URLSearchParams({
          latitude: lat, longitude: lon,
          current_weather: "true",
          temperature_unit: TEMP_UNITS==="f" ? "fahrenheit" : "celsius",
          windspeed_unit: "mph",
          timezone: "auto"
        });
        const resp = await fetch(`https://api.open-meteo.com/v1/forecast?${params.toString()}`, { cache: "no-store" });
        if (!resp.ok) throw new Error("OM HTTP " + resp.status);
        const w = await resp.json();
        const cw = w.current_weather;
        if (!cw) { elWxEmoji.textContent = "üåÄ"; elWeather.textContent = "??????"; elWxSeg.style.display="inline-flex"; return; }
        const temp = Math.round(cw.temperature);
        const code = Number(cw.weathercode);
        elWxEmoji.textContent = weatherEmoji(code);
        elWeather.textContent = `${temp}${TEMP_UNITS==="f" ? "¬∞F" : "¬∞C"} ${codeToText(code)}`;
        elWxSeg.style.display = "inline-flex";
      } catch (e) {
        console.warn("weather fail", e);
        elWxEmoji.textContent = "üåÄ"; elWeather.textContent = "??????"; elWxSeg.style.display="inline-flex";
      }
    }

    function weatherEmoji(code){
      if ([0].includes(code)) return "‚òÄÔ∏è";
      if ([1,2,3].includes(code)) return "üå§Ô∏è";
      if ([45,48].includes(code)) return "üå´Ô∏è";
      if ([51,53,55,56,57].includes(code)) return "üå¶Ô∏è";
      if ([61,63,65,66,67,80,81,82].includes(code)) return "üåßÔ∏è";
      if ([71,73,75,77,85,86].includes(code)) return "‚ùÑÔ∏è";
      if ([95,96,99].includes(code)) return "‚õàÔ∏è";
      return "‚òÅÔ∏è";
    }
    function codeToText(code){
      const map = {
        0:"Sunny",1:"Mostly Sunny",2:"Partly Cloudy",3:"Cloudy",
        45:"Foggy",48:"Icy Fog",
        51:"Light Drizzle",53:"Drizzle",55:"Heavy Drizzle",
        56:"Freezing Drizzle",57:"Heavy Freezing Drizzle",
        61:"Light Rain",63:"Rain",65:"Heavy Rain",
        66:"Freezing Rain",67:"Heavy Freezing Rain",
        71:"Light Snow",73:"Snow",75:"Heavy Snow",
        77:"Snow Grains",
        80:"Showers",81:"Heavy Showers",82:"Violent Showers",
        85:"Snow Showers",86:"Heavy Snow Showers",
        95:"Thunderstorm",96:"Thunderstorm With Hail",99:"Severe Thunderstorm"
      };
      return map[code] || "Clouds";
    }

    fetchRTIRL();
    setInterval(fetchRTIRL, 30000);
  </script>
</body>
</html>
