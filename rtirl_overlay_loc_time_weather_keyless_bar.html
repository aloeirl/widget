<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stream Overlay</title>

  <style>
    /* Self-hosted Arial Bold */
    @font-face {
      font-family: "OverlayArialBold";
      src: url("./fonts/ARIALBD.woff2?v=9") format("woff2");
      font-weight: 700;
      font-style: normal;
      font-display: block;
    }

    /* Self-hosted Emoji subset (Apple/Microsoft style you built) */
    @font-face {
      font-family: "OverlayAppleEmoji";
      src: url("./fonts/AppleColorEmoji-rtirl.woff2?v=9") format("woff2");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    :root {
      --bg: rgba(0,0,0,0.6);
      --fg: #ffffff;
      --border: rgba(255,255,255,0.4);
      --radius: 8px;
      --padY: 4px;
      --padX: 10px;
      --gap: 8px;
      --font: "OverlayArialBold", Arial, Helvetica, sans-serif;
    }

    html, body, #overlay, .segment, .sep, span, div, * {
      font-family: var(--font) !important;
      font-synthesis: none;
      -webkit-text-size-adjust: 100%;
      text-rendering: optimizeLegibility;
    }

    .emoji {
      font-family: "OverlayAppleEmoji","Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif !important;
      font-synthesis: none;
      line-height: 1;
      display: inline-block;
    }

    html, body { margin: 0; padding: 0; background: transparent; }
    body {
      display: inline-block;
      color: var(--fg);
      font-size: 16px;
      line-height: 1.2;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: var(--gap);
      padding: var(--padY) var(--padX);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: var(--bg);
      box-sizing: border-box;
      white-space: nowrap;
      box-shadow: 0 0 3px rgba(0,0,0,0.25), 0 1px 4px rgba(0,0,0,0.25);
      font-weight: 700;
    }

    .segment { display: inline-flex; align-items: center; gap: 6px; }
    .muted { opacity: 0.9; }
    .sep { color: var(--border); font-weight: 400; font-size: 0.85em; }
  </style>
</head>

<body>
  <div id="overlay" class="pill">
    <span id="locSeg" class="segment"><span class="emoji">üìç</span><span id="loc">Locating‚Ä¶</span></span>
    <span class="sep">|</span>
    <span id="timeSeg" class="segment"><span class="emoji">üïí</span><span id="time">--:-- --</span></span>
    <span class="sep">|</span>
    <span id="wxSeg" class="segment" style="display:none"><span id="wxEmoji" class="emoji">‚òÅÔ∏è</span><span id="weather" class="muted">--</span></span>
  </div>

  <script>
    const PULL_KEY = "1wjousu7l61hzgws";   // your RTIRL pull key
    const TEMP_UNITS = "f";                 // "f" or "c"
    const STALE_MS = 30 * 60 * 1000;        // 30 minutes
    const GRACE_MS = 3 * 60 * 60 * 1000;    // stationary grace (3h)

    let lastLat=null, lastLon=null, lastPlace=null, currentTZ=null, stale=false;

    const elLoc = document.getElementById("loc");
    const elTime = document.getElementById("time");
    const elWxSeg = document.getElementById("wxSeg");
    const elWeather = document.getElementById("weather");
    const elWxEmoji = document.getElementById("wxEmoji");

    /* ---------- TIME (auto-TZ from weather) ---------- */
    function to12h(date, tz) {
      const d = new Date(date.toLocaleString("en-US", {
        timeZone: tz || Intl.DateTimeFormat().resolvedOptions().timeZone
      }));
      let h = d.getHours();
      const m = d.getMinutes();
      const ampm = h >= 12 ? "pm" : "am";
      h = h % 12; if (h === 0) h = 12;
      return `${h}:${String(m).padStart(2, "0")} ${ampm}`;
    }

    function tickClock() {
      elTime.textContent = stale ? "??????" : to12h(new Date(), currentTZ);
    }
    setInterval(tickClock, 1000);
    tickClock();

    /* ---------- TIMESTAMPS ---------- */
    function normalizeTs(ts) {
      if (ts == null) return null;
      if (typeof ts === "string") { const d = Date.parse(ts); return Number.isNaN(d) ? null : d; }
      if (typeof ts === "number")  return ts < 1e12 ? ts * 1000 : ts; // sec‚Üíms
      return null;
    }
    function getLastUpdateMs(d) {
      const normalized = [
        d?.updatedAt, d?.reportedAt, d?.timestamp,
        d?.location?.updatedAt, d?.location?.reportedAt
      ].map(normalizeTs).filter(v => typeof v === "number" && !Number.isNaN(v));
      return normalized.length ? Math.max(...normalized) : null;
    }

    /* ---------- HELPERS ---------- */
    function approxEqual(a,b,eps=1e-4){ if(a==null||b==null) return false; return Math.abs(a-b)<=eps; }
    function extractLatLon(d){
      if (d?.location && typeof d.location.latitude==="number" && typeof d.location.longitude==="number") {
        return {lat:d.location.latitude, lon:d.location.longitude};
      }
      if (typeof d.lat==="number" && typeof d.lon==="number") return {lat:d.lat, lon:d.lon};
      if (typeof d.latitude==="number" && typeof d.longitude==="number") return {lat:d.latitude, lon:d.longitude};
      if (d?.coords && typeof d.coords.lat==="number" && typeof d.coords.lon==="number") return {lat:d.coords.lat, lon:d.coords.lon};
      return null;
    }

    function showUnknown() {
      stale = true;
      elLoc.textContent = "??????";
      elTime.textContent = "??????";
      elWeather.textContent = "??????";
      elWxEmoji.textContent = "üåÄ";
      elWxSeg.style.display = "inline-flex";
    }

    /* ---------- LOCATION NAME (strip ch≈çme/block numbers) ---------- */
    async function reverseGeocode(lat, lon) {
      const url = new URL("https://nominatim.openstreetmap.org/reverse");
      url.searchParams.set("format", "jsonv2");
      url.searchParams.set("lat", String(lat));
      url.searchParams.set("lon", String(lon));
      url.searchParams.set("accept-language", "en");
      url.searchParams.set("zoom", "15");
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("Nominatim HTTP " + res.status);
      const j = await res.json();
      const addr = j.address || {};

      const rawArea =
        addr.neighbourhood || addr.neighborhood ||
        addr.quarter || addr.suburb || addr.district || "";

      const rawWard =
        addr.city_district || addr.ward || addr.borough ||
        addr.city || addr.town || addr.village || "";

      function cleanName(s) {
        if (!s) return "";
        let out = s.trim();
        // remove "2-chome", "2 chome", "Ôºí‰∏ÅÁõÆ", "2‰∏ÅÁõÆ", trailing numbers like "Ikejiri 2"
        out = out
          .replace(/\s*\d+\s*-?\s*chome\b/iu, "")
          .replace(/\s*[Ôºê-Ôºô]+\s*‰∏ÅÁõÆ\b/u, "")
          .replace(/\s*\d+\s*‰∏ÅÁõÆ\b/u, "")
          .replace(/\s+\d+([\-‚Äì]\d+)*\s*$/u, "")
          .replace(/\s+City$/i, "")
          .replace(/\s{2,}/g, " ")
          .trim();
        return out;
      }

      const area = cleanName(rawArea);
      const ward = cleanName(rawWard);
      const parts = [area, ward].filter(Boolean);
      if (parts.length) return parts.join(", ");
      return (j.display_name || "").split(", ").slice(0,2).join(", ");
    }

    /* ---------- WEATHER + TIMEZONE ---------- */
    async function updateWeather(lat, lon) {
      try {
        const params = new URLSearchParams({
          latitude: lat, longitude: lon,
          current_weather: "true",
          temperature_unit: TEMP_UNITS==="f" ? "fahrenheit" : "celsius",
          windspeed_unit: "mph",
          timezone: "auto"
        });
        const resp = await fetch(`https://api.open-meteo.com/v1/forecast?${params.toString()}`, { cache: "no-store" });
        if (!resp.ok) throw new Error("OM HTTP " + resp.status);
        const w = await resp.json();

        if (w && typeof w.timezone === "string") currentTZ = w.timezone;

        const cw = w.current_weather;
        if (!cw) { elWxEmoji.textContent = "üåÄ"; elWeather.textContent = "??????"; elWxSeg.style.display = "inline-flex"; return; }

        const temp = Math.round(cw.temperature);
        const code = Number(cw.weathercode);
        elWxEmoji.textContent = weatherEmoji(code);
        elWeather.textContent = `${temp}${TEMP_UNITS==="f" ? "¬∞F" : "¬∞C"} ${codeToText(code)}`;
        elWxSeg.style.display = "inline-flex";
      } catch (e) {
        console.warn("weather fail", e);
        elWxEmoji.textContent = "üåÄ"; elWeather.textContent = "??????"; elWxSeg.style.display = "inline-flex";
      }
    }

    /* ---------- DAY/NIGHT + LABELS ---------- */
    function isNight(tz) {
      const local = new Date(new Date().toLocaleString("en-US", { timeZone: tz || "UTC" }));
      const hour = local.getHours();
      return (hour < 6 || hour >= 18); // 6pm‚Äì6am considered night
    }

    // Emojis: only "Clear" switches to üåô at night per your request
    function weatherEmoji(code){
      const night = isNight(currentTZ);
      if (code === 0) return night ? "üåô" : "‚òÄÔ∏è"; // Clear day/night
      if ([1,2,3].includes(code)) return "üå§Ô∏è";
      if ([45,48].includes(code)) return "üå´Ô∏è";
      if ([51,53,55,56,57].includes(code)) return "üå¶Ô∏è";
      if ([61,63,65,66,67,80,81,82].includes(code)) return "üåßÔ∏è";
      if ([71,73,75,77,85,86].includes(code)) return "‚ùÑÔ∏è";
      if ([95,96,99].includes(code)) return "‚õàÔ∏è";
      return "‚òÅÔ∏è";
    }

    // Unified, time-neutral wording
    function codeToText(code){
      const map = {
        0:"Clear",
        1:"Mostly Clear",
        2:"Partly Cloudy",
        3:"Cloudy",
        45:"Foggy",
        48:"Icy Fog",
        51:"Light Drizzle",
        53:"Drizzle",
        55:"Heavy Drizzle",
        56:"Freezing Drizzle",
        57:"Heavy Freezing Drizzle",
        61:"Light Rain",
        63:"Rain",
        65:"Heavy Rain",
        66:"Freezing Rain",
        67:"Heavy Freezing Rain",
        71:"Light Snow",
        73:"Snow",
        75:"Heavy Snow",
        77:"Snow Grains",
        80:"Showers",
        81:"Heavy Showers",
        82:"Violent Showers",
        85:"Snow Showers",
        86:"Heavy Snow Showers",
        95:"Thunderstorm",
        96:"Thunderstorm With Hail",
        99:"Severe Thunderstorm"
      };
      return map[code] || "Clouds";
    }

    /* ---------- MAIN PULL ---------- */
    async function fetchRTIRL() {
      try {
        const res = await fetch(`https://rtirl.com/api/pull?key=${encodeURIComponent(PULL_KEY)}&ts=${Date.now()}`, { cache: "no-store" });
        if (!res.ok) throw new Error("RTIRL pull failed");
        const data = await res.json();

        const lastUpdate = getLastUpdateMs(data);
        const coords = extractLatLon(data);

        if (!coords) { showUnknown(); return; }

        let tooOld = !lastUpdate || (Date.now() - lastUpdate > STALE_MS);

        // Stationary grace if coords unchanged
        if (tooOld && lastLat!=null && lastLon!=null) {
          const unchanged = approxEqual(coords.lat, lastLat) && approxEqual(coords.lon, lastLon);
          const age = lastUpdate ? (Date.now() - lastUpdate) : Infinity;
          if (unchanged && age < GRACE_MS) tooOld = false;
        }

        if (tooOld) { showUnknown(); return; }

        stale = false;
        const { lat, lon } = coords;

        if (!lastPlace || !approxEqual(lat,lastLat) || !approxEqual(lon,lastLon)) {
          reverseGeocode(lat, lon)
            .then(name => { if (name) { lastPlace = name; elLoc.textContent = name; } })
            .catch(() => { elLoc.textContent = lastPlace || "??????"; });
          lastLat = lat; lastLon = lon;
        } else {
          elLoc.textContent = lastPlace;
        }

        updateWeather(lat, lon);
      } catch (e) {
        console.error(e);
        showUnknown();
      }
    }

    // initial + every 30s
    fetchRTIRL();
    setInterval(fetchRTIRL, 30000);
  </script>
</body>
</html>
