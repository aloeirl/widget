<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stream Overlay</title>

  <style>
    /* Self-hosted Arial Bold */
    @font-face {
      font-family: "OverlayArialBold";
      src: url("./fonts/ARIALBD.woff2?v=4") format("woff2");
      font-weight: 700;
      font-style: normal;
      font-display: block;
    }

    /* Self-hosted Apple Emoji subset (pyftsubset output) */
    @font-face {
      font-family: "OverlayAppleEmoji";
      src: url("./fonts/AppleColorEmoji-rtirl.woff2?v=4") format("woff2");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    :root {
      --bg: rgba(0,0,0,0.6);
      --fg: #ffffff;
      --border: rgba(255,255,255,0.4);
      --radius: 8px;
      --padY: 4px;
      --padX: 10px;
      --gap: 8px;
      --font: "OverlayArialBold", Arial, Helvetica, sans-serif;
    }

    /* Text uses Arial Bold everywhere */
    html, body, #overlay, .segment, .sep, span, div, * {
      font-family: var(--font) !important;
      font-synthesis: none;
      -webkit-text-size-adjust: 100%;
      text-rendering: optimizeLegibility;
    }

    /* Emoji spans explicitly use emoji font */
    .emoji {
      font-family: "OverlayAppleEmoji","Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif !important;
      font-synthesis: none;
      line-height: 1;
      display: inline-block;
    }

    html, body { margin: 0; padding: 0; background: transparent; }
    body {
      display: inline-block;
      color: var(--fg);
      font-size: 16px;
      line-height: 1.2;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: var(--gap);
      padding: var(--padY) var(--padX);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      background: var(--bg);
      box-sizing: border-box;
      white-space: nowrap;
      box-shadow: 0 0 3px rgba(0,0,0,0.25), 0 1px 4px rgba(0,0,0,0.25);
      font-weight: 700;
    }

    .segment { display: inline-flex; align-items: center; gap: 6px; }
    .sep { color: var(--border); font-weight: 400; font-size: 0.85em; }
  </style>
</head>
<body>
  <div id="overlay" class="pill">
    <span id="locSeg" class="segment"><span class="emoji">üìç</span><span id="loc">Locating‚Ä¶</span></span>
    <span class="sep">|</span>
    <span id="timeSeg" class="segment"><span class="emoji">üïí</span><span id="time">--:-- --</span></span>
    <span class="sep">|</span>
    <span id="wxSeg" class="segment" style="display:none"><span id="wxEmoji" class="emoji">‚òÅÔ∏è</span><span id="weather">--</span></span>
  </div>

  <script>
    const PULL_KEY = "1wjousu7l61hzgws";   // your working key
    const TEMP_UNITS = "f";
    const STALE_MS = 30 * 60 * 1000;       // 30 minutes

    const elLoc = document.getElementById("loc");
    const elTime = document.getElementById("time");
    const elWxSeg = document.getElementById("wxSeg");
    const elWeather = document.getElementById("weather");
    const elWxEmoji = document.getElementById("wxEmoji");

    let stale = false;
    let lastLat = null, lastLon = null, lastPlace = null;

    // --- clock ---
    function to12h(date) {
      let h = date.getHours();
      const m = date.getMinutes();
      const ampm = h >= 12 ? "pm" : "am";
      h = h % 12; if (h === 0) h = 12;
      return `${h}:${String(m).padStart(2, "0")} ${ampm}`;
    }
    function tickClock() {
      elTime.textContent = stale ? "??????" : to12h(new Date());
    }
    setInterval(tickClock, 1000); tickClock();

    // --- timestamp handling (robust) ---
    function normalizeTs(ts) {
      if (ts == null) return null;
      if (typeof ts === "string") {
        const d = Date.parse(ts);
        return Number.isNaN(d) ? null : d;
      }
      if (typeof ts === "number") {
        return ts < 1e12 ? ts * 1000 : ts; // seconds -> ms
      }
      return null;
    }
    function getLastUpdateMs(d) {
      const normalized = [
        d?.updatedAt, d?.reportedAt, d?.timestamp,
        d?.location?.updatedAt, d?.location?.reportedAt
      ].map(normalizeTs).filter(v => typeof v === "number" && !Number.isNaN(v));
      return normalized.length ? Math.max(...normalized) : null;
    }

    // --- helpers ---
    function approxEqual(a,b,eps=1e-4){ if(a==null||b==null) return false; return Math.abs(a-b)<=eps; }
    function extractLatLon(d){
      if (d?.location && typeof d.location.latitude==="number" && typeof d.location.longitude==="number") return {lat:d.location.latitude, lon:d.location.longitude};
      if (typeof d.lat==="number" && typeof d.lon==="number") return {lat:d.lat, lon:d.lon};
      if (typeof d.latitude==="number" && typeof d.longitude==="number") return {lat:d.latitude, lon:d.longitude};
      if (d?.coords && typeof d.coords.lat==="number" && typeof d.coords.lon==="number") return {lat:d.coords.lat, lon:d.coords.lon};
      return null;
    }

    async function reverseGeocode(lat, lon) {
      const url = new URL("https://nominatim.openstreetmap.org/reverse");
      url.searchParams.set("format", "jsonv2");
      url.searchParams.set("lat", String(lat));
      url.searchParams.set("lon", String(lon));
      url.searchParams.set("accept-language", "en");
      url.searchParams.set("zoom", "15");
      const res = await fetch(url.toString(), { cache: "no-store" });
      if (!res.ok) throw new Error("Nominatim HTTP " + res.status);
      const j = await res.json();
      const addr = j.address || {};
      const parts = [
        addr.neighbourhood || addr.neighborhood || "",
        addr.suburb || "",
        addr.city || addr.town || addr.village || "",
      ].filter(Boolean);
      return parts.length ? parts.join(", ") : (j.display_name || "").split(", ").slice(0,3).join(", ");
    }

    // --- RTIRL pull (decides stale/unknown) ---
    async function fetchRTIRL() {
      try {
        const url = `https://rtirl.com/api/pull?key=${encodeURIComponent(PULL_KEY)}&ts=${Date.now()}`;
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error("RTIRL pull failed");
        const data = await res.json();

        const lastUpdate = getLastUpdateMs(data);
        const tooOld = !lastUpdate || (Date.now() - lastUpdate > STALE_MS);

        const coords = extractLatLon(data);
        if (tooOld || !coords) { showUnknown(); return; }

        // ‚úÖ fresh data: clear stale immediately
        stale = false;

        const { lat, lon } = coords;

        // show raw coords immediately so we never look "stuck"
        elLoc.textContent = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;

        // then try to replace with a nice name
        if (!lastPlace || !approxEqual(lat,lastLat) || !approxEqual(lon,lastLon)) {
          reverseGeocode(lat, lon)
            .then(name => { if (name) { lastPlace = name; elLoc.textContent = name; } })
            .catch(() => { /* keep coords if geocode fails */ });
          lastLat = lat; lastLon = lon;
        } else {
          elLoc.textContent = lastPlace;
        }

        // weather can fail independently without blanking everything
        updateWeather(lat, lon);

      } catch (e) {
        console.error(e);
        showUnknown();
      }
    }

    function showUnknown() {
      stale = true;
      elLoc.textContent = "??????";
      elTime.textContent = "??????";
      elWxEmoji.textContent = "üåÄ";
      elWeather.textContent = "??????";
      elWxSeg.style.display = "inline-flex";
    }

    // --- Weather (does NOT flip whole widget to ?????? on failure) ---
    async function updateWeather(lat, lon) {
      try {
        const params = new URLSearchParams({
          latitude: lat, longitude: lon,
          current_weather: "true",
          temperature_unit: TEMP_UNITS==="f" ? "fahrenheit" : "celsius",
          windspeed_unit: "mph",
          timezone: "auto"
        });
        const resp = await fetch(`https://api.open-meteo.com/v1/forecast?${params.toString()}`, { cache: "no-store" });
        if (!resp.ok) throw new Error("OM HTTP " + resp.status);
        const w = await res.json();
      } catch(e){}
    }
  </script>
</body>
</html>
